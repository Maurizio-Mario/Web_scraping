---
title: "readLines"
author: "Maurizio Murino"
date: "22 April 2016"
output: html_document
---
In this exercise I will scrape text from the rstudio blog on [web scraping](https://blog.rstudio.org/2014/11/24/rvest-easy-web-scraping-with-r/).

Let's first create a connection with the website. With it, we are going import the website structure with `readLines`. Finally, we close the connection.

```{r 1}
con <- url("https://blog.rstudio.org/2014/11/24/rvest-easy-web-scraping-with-r/")
page1 <- readLines(con)
close(con)
```

Now, we have a 798 lines long file. For this exercise, I will have a look to its structure open the file with a text editor. Different and more effective solutions, such as [Selector gadgets](http://selectorgadget.com/) (which is discussed in the scraped page) and nodes will be used in another excercise.

```{r 2}
length(page1)
write.table(page1, "page1.txt")
```

In this phase we are interest in the text. So let's open the `page1.txt` file with a text editor. The first material of our interest is at line 117, 121, 124, 130.

```{r 3}
a <- page1[c(117, 121, 124, 130)]
a
```

Gotcha! Precisely what we need. Let's clean it a little. Luckly, it is quite neat.

```{r 4}
a <- gsub("<.*?>", "", a, perl = TRUE)
a <- gsub("\t\t", "", a, fixed = TRUE)
a <- gsub("â€™", "", a, fixed = TRUE)
a <- gsub("(&quot;selectorgadget&quot;) &#8211", "", a, fixed = TRUE)
a
```

Beautiful. Now, we can load the `tm` package (Feinerer & Hornik, 2013) and convert our vector of character strings into a recognizable corpus of text using the `VectorSource` function and the `Corpus` function.

```{r 5, warning=FALSE}
library(tm)
library(SnowballC)
txt <- VectorSource(a); rm(a)
txtCorpus <- Corpus(txt)

# Information on the documents of the corpus
inspect(txtCorpus)

# Which id/key is assigned to every document
meta(txtCorpus, "id")

# Plot the text of a document from the corpus
writeLines(as.character(txtCorpus[[3]]))

# Print every document in the corpus
lapply(txtCorpus, as.character)
```

Next, we make some adjustments to the text:

* everything lower case; 
* removing punctuation; 
* removing numbers, 
* removing common English stop words. 

The `tm map` function allows us to apply transformation functions to a corpus.

```{r 6}
txtCorpus <- tm_map(txtCorpus, tolower)
txtCorpus <- tm_map(txtCorpus, removePunctuation)
txtCorpus <- tm_map(txtCorpus, removeNumbers)
txtCorpus <- tm_map(txtCorpus, removeWords, stopwords("english"))

writeLines(as.character(txtCorpus[[3]]))
```

What an human friendly result! But we are not over yet. Next we stem the text. Stemming truncates words (e.g., “compute”, “computes” & “computing” all
become “comput”). However, we need to load the `SnowballC` package (Bouchet-Valat, 2013) which allows us to identify specific stem elements using the `tm_map` function of the `tm` package.

```{r 7}
txtCorpus <- tm_map(txtCorpus, stemDocument)
detach("package:SnowballC")
inspect(txtCorpus)
```

Time to remove every empty space generated by isolating the word stems in the previous step. We use the `stripWhitespace` argument of the `tm map` function to accomplish this task.

```{r 8}
txtCorpus <- tm_map(txtCorpus, stripWhitespace)
inspect(txtCorpus)
```

Finally, we can analyze the text. First, we create a Term Document Matrix (TDM), that is, a matrix of frequency counts for each word used in the corpus. Below we only show the first 20 words and their frequencies in each document (i.e. for us, each ‘document’ is a section from the rStudio blog).

A particular mention goes to the first function. `TermDocumentMatrix` seems would have worked just fine in tm 0.5.10 but changes in tm 0.6.0 seems to have broken it. The problem is that the functions tolower and trim won't necessarily return TextDocuments (it looks like the older version may have automatically done the conversion). They instead return characters and the DocumentTermMatrix isn't sure how to handle a corpus of characters.

Hence, after all of your non-standard transformations (those not in getTransformations()) are done and just before the creation of the DocumentTermMatrix, you should run `tm_map(txtCorpus, PlainTextDocument)`. That should make sure all the data is in PlainTextDocument and should make DocumentTermMatrix happy.

```{r 9}
txtCorpus2 <- tm_map(txtCorpus, PlainTextDocument)
tdm <- TermDocumentMatrix(txtCorpus2)
inspect(tdm[1:20, ] )
```

Next, we can begin to explore the TDM, using the `findFreqTerms` function, to find which words were used most. Below we specify that we want term / word stems which were used 2 or more times (in all documents / paragraphs).

```{r 10}
findFreqTerms(tdm, lowfreq = 2, highfreq = Inf)
```

With the `findAssocs` function we find words associated together. We are specifying the TDM to use, the term we want to find associates for, and the lowest acceptable correlation limit with that term. This returns a vector of terms which are associated with `"data"` at r = 0.60 or more, and that reports each association in descending order.

```{r 11}
findAssocs(tdm, "data", corlimit = .6)
```
Eventually, terms which occur very infrequently (i.e. sparse terms) can be removed, leaving only the ‘common’ terms. Below, the `sparse` argument refers to the maximum sparse-ness allowed for a term to be in the returned matrix; in other words, the larger the percentage, the more terms will be retained, the smaller the percentage, the fewer (but more common) terms will be retained.


```{r 11}
tdmCommon.2 <- removeSparseTerms(tdm, sparse = 0.20)
tdmCommon.2
tdmCommon.6 <- removeSparseTerms(tdm, sparse = 0.60)
inspect(tdmCommon.2)
inspect(tdmCommon.6)
```

We can review the terms returned from a specific sparse-ness by using the `inspect` function with the TDMs containing those specific sparse-ness rates (i.e. the terms retained at specific spare-ness levels). 
Below we see the 20 terms returned when sparse-ness is set to 0.60. When sparse-ness is set to 0.20 we have no term! Afterall, the data we selected were quite small.

An that is my first taxt analysis with web scraping included.


